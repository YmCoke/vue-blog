# 位运算

## 前情提要

本篇主要介绍一些常用的位运算操作, 它并不困难, 但需要具备一些组成原理的基本概念, 如原码, 补码, 反码.

### 求n的二进制表示中第k位

这里k从0开始, 二进制表达式的最左边表示第0位. 

我们可以分俩步来求: 

1. 得到n二进制表达式的第k位: x = n >> k

2. 第k位是什么: ans = x & 1

ans若为1则表示第k位为1, 为0则表示第k位为0.

有一个很简单的应用场景: 它可以用于求一个整数的二进制表达式. 代码如下:

```js
function get(n) {
    let res = Array.from({length: 32});
    for(let i = 0; i < 32; i ++) {
        res[i] = (n >> i) & 1;
    return res.reverse().join("");
}
```

### lowbit运算

lowbit运算用于求出某一个数二进制表达式最后一个1对应的值(这里文字不好描述, 看下面的例子). 比如说: 

**下面(xxxx)2代表xxxx是二进制表达式**

```
10的二进制表达式是: (1010)2, lowbit(10) => (10)2 => 2
13的二进制表达式是: (1101)2, lowbit(13) => (1)2 => 1
144的二进制表达式是: (10010000), lowbit(144) => (10000) => 2^4 = 16
```

下面我们来实现`lowbit`函数

```js
function lowbit(x) {
    return x & -x;
}
```

没错只有一行代码, 如果你想要了解原理的话, 请看下面的进阶部分.

这里先给出一道lowbit具体应用的题目: [leetcode: 191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

> 本题要求编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）  

我们只需要每次求出n最后一位1, 然后将n的最后一个1删去, 重复这个操作直到n变成0即可. 进行几次运算就代表这个n有多少个1. 代码如下

对于本题有个坑我要先提一下, 因为js是有符号数的. 所以1 << 31会导致溢出. 我们让它变成大整型即可(具体操作没接触过的可以看一下MDN文档)

```js
var hammingWeight = function (n) {
    n = BigInt(n); 
    let ans = 0;
    while (n) n -= n & -n, ans ++;
    return ans;
};
```

## 进阶

为什么x & -x可以得到最后一位1

```
-x = 0 - x
在计算机中, 是32位整型, 实际上我们计算0 - x的时候我们需要向前面借一位. 实际上就是:
   = 1 << 32 - x
   = 100000000000000000000000000000000 - x
   = 11111111111111111111111111111111 - x + 1
对于11111111111111111111111111111111 - x我们可以发现, x二进制位上0会变成1, 1会变成0. 也就是x取反
   = ~x + 1
   = x的补码
```

经过上面的疯狂证明我们可以发现-x实际上是x的补码. 那么我们只需要看一下x & x补码的结果就可以了

根据定义, 从x变成x补码的过程其实是: **x最后一个1以及后面的0不变, 然后前面全部取反**

x & -x的结果就会变成, 只留下最后一位1以及剩下的位数上的0.

如果你看不懂这个过程的话, 那么你的计算机理论基础相对薄弱一些, 可以先看一下补一下计算机组成原理的相关知识.