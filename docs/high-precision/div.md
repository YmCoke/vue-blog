# 高精度除法

实现一个函数, 实现a / b. (其中**a是string, b是number**, 保证b不为0), 返回一个对象, 对象要求包含俩个属性: **余数r, 商s**

::: tip
高精度除法与前面几个高精度不同, 考虑到双高精度除法实现的难度过高. 故换成单高精度的除法运算
:::

高精度除法与前面几个高精度运算不太相同, 有自己独自的一套计算过程. 但换汤不换药, 写起代码来还是差不多的, 在看代码之前, 需要先知道几个细节

1. 除法的运算是从高位开始的, 与加减乘不同

2. 代码中变量含义: b是余数, r是余数, s是商

3. 建议在看代码前在纸上模拟一遍除法的运算流程

## 代码模板

```js
function div(a, b) {
    /* 将a的每一位摘出来, 以低位的方式存储到A数组中. 省略... */

    const C = [];
    let r = 0;
    
    /* 核心逻辑 */
    for(let i = A.length - 1; i >= 0; i --) {
        r = r * 10 + A[i];
        C.push(Math.floor(r / b));
        r = r % b;
    }

    /* 处理结果 */
    reverse(0, C.length - 1, C);
    while(C.length > 1 && C[C.length - 1] == 0) C.pop();
    let s = "";
    for(let i = C.length - 1; i >= 0; i --) s += C[i];
    return {r: r, s: s}
}
// 逆转数组的元素
function reverse(l, r, arr) {
    let i = l, j = r;
    while(i < j) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
        i ++, j --;
    }
}
```

## 代码讲解

1. 核心代码逻辑

```js
r = r * 10 + A[i]
C.push(Math.floor(r / b));
r = r % b;
```

**当前位计算的结果(`C[i]`), 等于于上一次计算余下的值(`r`)拼上当前位的值(`A[i]`)除于`b`向下取整的结果**. 

除完后剩余的值参与下次计算. 所以当前为余下的值为`r = r % b`

2. 为什么要将结果数组C进行逆转后再去除前导0

如果直接判断数组的第一项是否为0, 用shift方法的话, 也可以实现去除前导0的效果. 但如果存在多个前导0的话效率会很低, **因为会进行多次shift操作, 也就是把数组中每一位的元素不断的往前挪**. 如果有k个前导0, 那么时间复杂度就是O(kN).

为保证算法时间复杂度的稳定性, 我们采取先逆转数组, 再使用pop的方式去除前导0. pop的时间复杂度是O(1), 逆转的时间复杂度是O(n). 这样时间复杂度就可以稳定在O(n)

3. reverse方法

使用俩个指针分别指向要逆转的区间的左端点和右端点, 不断交换对称的俩个元素, 交换后前面的指针后移, 后面的指针前移. 当俩指针相遇时, 逆转结束.

该方法: 时间复杂度: O(n), 空间复杂度: O(1)