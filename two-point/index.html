<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>双指针算法 | coke的博客</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/vue-blog/favicon.ico">
    <link rel="manifest" href="/vue-blog/manifest.json">
    <meta name="description" content="专注于写算法的前端工程师">
    <link rel="preload" href="/vue-blog/assets/css/0.styles.0e7090cc.css" as="style"><link rel="preload" href="/vue-blog/assets/js/app.b8a6785c.js" as="script"><link rel="preload" href="/vue-blog/assets/js/2.6251e0ea.js" as="script"><link rel="preload" href="/vue-blog/assets/js/20.b69d0ffe.js" as="script"><link rel="prefetch" href="/vue-blog/assets/js/10.eb74e050.js"><link rel="prefetch" href="/vue-blog/assets/js/11.a79ab868.js"><link rel="prefetch" href="/vue-blog/assets/js/12.030b1b17.js"><link rel="prefetch" href="/vue-blog/assets/js/13.9f750832.js"><link rel="prefetch" href="/vue-blog/assets/js/14.4b8703c5.js"><link rel="prefetch" href="/vue-blog/assets/js/15.367d06d7.js"><link rel="prefetch" href="/vue-blog/assets/js/16.13761067.js"><link rel="prefetch" href="/vue-blog/assets/js/17.834bc26c.js"><link rel="prefetch" href="/vue-blog/assets/js/18.d00d783a.js"><link rel="prefetch" href="/vue-blog/assets/js/19.5121ff35.js"><link rel="prefetch" href="/vue-blog/assets/js/3.6be60106.js"><link rel="prefetch" href="/vue-blog/assets/js/4.88c50503.js"><link rel="prefetch" href="/vue-blog/assets/js/5.0d2e8757.js"><link rel="prefetch" href="/vue-blog/assets/js/6.c87d310a.js"><link rel="prefetch" href="/vue-blog/assets/js/7.80e02e68.js"><link rel="prefetch" href="/vue-blog/assets/js/8.0f07b5a4.js"><link rel="prefetch" href="/vue-blog/assets/js/9.fa966027.js">
    <link rel="stylesheet" href="/vue-blog/assets/css/0.styles.0e7090cc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-blog/" class="home-link router-link-active"><!----> <span class="site-name">coke的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二分算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>高精度运算</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前缀和与差分</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>双指针算法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-blog/two-point/" aria-current="page" class="active sidebar-link">双指针算法</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>位运算</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>单调栈</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="双指针算法"><a href="#双指针算法" class="header-anchor">#</a> 双指针算法</h1> <h2 id="算法介绍"><a href="#算法介绍" class="header-anchor">#</a> 算法介绍</h2> <p>双指针算法其实不是一种特定的算法, 更像是一种思想. 它十分巧妙, 应用也十分广泛, 只要你发现当前问题具备<strong>单调性</strong>, 那么你就可以尝试使用这种思想来优化现有的解决方案. 通常用于提高性能(经典的从O(n^2)优化成O(n)).</p> <p>从上面的描述你可以看出, <strong>双指针是用于优化我们原有的解决方案的</strong>. 也就是说, 对于某一个问题, 我们都会先想出一个最朴素的作法(直观的作法), 然后再对其进行优化. 但是因为双指针这个四星比较抽象, 所以我们还是利用题目来帮助大家理解.</p> <h2 id="适用场景"><a href="#适用场景" class="header-anchor">#</a> 适用场景</h2> <p>我们先说一下双指针的适用场景, 对于某一个问题, 如果你发现了具备<strong>单调性</strong>, 那么你就可以尝试使用双指针进行优化.</p> <h2 id="具体案例"><a href="#具体案例" class="header-anchor">#</a> 具体案例</h2> <h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="header-anchor">#</a> <code>无重复字符的最长子串</code></h3> <blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度<br>
eg: input: &quot;abcabcbb&quot;, 最长子串是&quot;abc&quot;, 故返回答案3</p></blockquote> <p>原题链接: <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener noreferrer">leetcode: 3. 无重复字符的最长子串<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>对于这道题, 我们很容易就想到的一种做法是, 遍历所有字符, 求出以当前字符结尾的最长无重复连续子串的长度. 然后去个max就ok. 具体代码如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">lengthOfLongestSubstring</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">,</span> hash <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            j <span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ans <span class="token operator">&lt;</span> i <span class="token operator">-</span> j<span class="token punctuation">)</span> ans <span class="token operator">=</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>可以发现, 该算法的时间复杂度是O(n ^ 2)的, 需要进行俩重循环. 接下来我们就来思考一下本题是否具备我们上面所说的<strong>单调性</strong>.</p> <p>对于每一个字符(<strong>下面用i来代表该字符的下标</strong>)来说, 都会对应着存在一个在它左边的字符(<strong>下面用j来代表该字符的下标</strong>)距离它最远, 且满足s[j ~ i]区间中不存在重复字符的情况. 那么, i和j的具备一种关系: <strong>当i向右走的时候, j只可能不动或者向右走而不可能向左走</strong>.</p> <p>下面我们就来论证一下它们的关系是否是正确的, 如果是正确的, 那么我们就可以说它具备单调性(建议论证过程大家可以画个图理解一下)</p> <p>想象字符串是一个数轴, 在j ~ i这个区间是<strong>以s[i]字符结尾的无重复字符的最长子串</strong>. 这个区间有什么特点呢? 只要j往左移动一位, 那么该区间就会具有重复字符, 即j就是一个左边界. 而当i右移会如何呢? 它意味这个区间会引入一个新的字符, 这个新字符有俩种可能:</p> <ul><li>它是原区间未出现过的字符</li> <li>它是原区间存在过的字符</li></ul> <p>为了保证区间具备<strong>无重复字符</strong>这一特点, 对这俩种情况我们有不同的处理方案:</p> <ol><li>引入未出现过的字符, 那么j不需要变化.</li> <li>引入原区间存在过的字符, 那么j就应该向后移动, 直到不存在重复字符为止.</li></ol> <p>至此, 我们就可以得出结论, <strong>当i增加的时候, j只可能增加而不可能减少</strong>. 即具备单调性.</p> <p>既然证明出了具备单调性, 我们就可以使用双指针来进行优化, 具体的实现思路其实我们在上面已经透露了. 就是动态维护一个区间, 左端点是j, 右端点是i. 让该区间一直都具备<strong>它是以s[i]字符结尾的无重复字符的最长子串</strong>这一性质即可. 代码如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">lengthOfLongestSubstring</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hash <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// hash: 用于记录字符出现的次数</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 这里是为了解决undefined与number类型做运算为NaN的情况.</span>
        hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j <span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 由于原区间是不存在重复字符的, 所以如果引入新字符导致有重复字符的话, 那么肯定是新字符搞的鬼. </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ans <span class="token operator">&lt;</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 为什么是 i - j + 1, 主要是因为最后i和j是我们维护这个区间的左右端点, 大家拿笔算一下就可以了.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span> <span class="token comment">// 最后将答案返回.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>好的最后让我们来分析一下时间复杂度, 虽然代码看上去有俩重循环, 但是在我们的思路中我们可以看到, <strong>i和j都是始终向后移动的, 最多i和j就是从头走到尾, 也就是遍历俩次数组</strong>. 时间复杂度是O(2n). 但通常常数不算, 所以我们的时间复杂度是O(n)的. 至此, 我们就将双指针是如何一步步优化原有方案的过程给大家讲完了.</p> <h3 id="额外题目"><a href="#额外题目" class="header-anchor">#</a> 额外题目</h3> <p>原题链接: <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener noreferrer">leetcode: 167. 两数之和 II - 输入有序数组<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>鉴于双指针比较抽象, 所以多准备了一道题目帮助大家理解. 但这里我就不写出这道题的具体分析思路. 这里给大家推荐B站大雪莱大神讲解这道双指针题目的视频, 感兴趣的同学可以看一下: <a href="https://www.bilibili.com/video/BV1t4411o7i6?from=search&amp;seid=2835749648378197324" target="_blank" rel="noopener noreferrer">视频链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>双指针相对来说还是比较简单的, 主要是需要自己动笔在纸上画一画, 自行分析一遍. 切忌只在脑中思考, 那样只会导致你的头发在不停的&quot;燃烧&quot;... 然后就是多做几道习题巩固一下, Leetcode上面有双指针的tag. 可以很好的帮助你们熟练的掌握这个思想.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-blog/prefix-sum&amp;difference/difference.html" class="prev">
        差分算法
      </a></span> <span class="next"><a href="/vue-blog/bit/">
        lowbit算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-blog/assets/js/app.b8a6785c.js" defer></script><script src="/vue-blog/assets/js/2.6251e0ea.js" defer></script><script src="/vue-blog/assets/js/20.b69d0ffe.js" defer></script>
  </body>
</html>
